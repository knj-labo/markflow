# RSMD設計書（詳細版）

> 目的：**最小・高速・安定ABI**。Astro 連携を第一要件とし、Markdown → HTML + 見出し情報（`headings[]`）のみを安定形式で返す。

---

## 1. ゴール / 非目標

### ゴール

* **高速**：単一パスで HTML を生成しながら見出しを収集。小さな wasm バイナリ、低メモリ。
* **シンプル**：返り値は `{ html, headings }` 固定。フロントマターや高度変換は JS 側で処理。
* **統合**：Astro Content Collections との自然な統合（同期的 API / 安定したスラグ）。

### 非目標（現段階）

* プラグインシステムや AST 操作（必要になれば将来拡張）。
* 既定の HTML サニタイズ（オプションで二重パスを検討）。
* フル MDX 実装（現状は .md 専用。MDX は JS 経路で後付け）。

---

## 2. 全体アーキテクチャ

```
[Markdown (.md)]
   │
   ▼   （gray-matter でフロントマター分離）
[JS/Astro]
   │  body + options（既定ON）
   ▼
[wasm]  render(source, options)
   │  （境界：シリアライズ / 初期化）
   ▼
[core]  render(src, &Options)
   │  単一パス：pulldown-cmark → <hN id> を生成しつつ headings を収集
   ▼
RenderResult { html, headings[] }
   │
   ▼
[JS/Astro]  任意のポスト処理（外部リンク rel, TOC など）
```

* **層ごとの公開関数名は `render` に統一**。
* ABI（返り値の JSON 形）は**固定**。

---

## 3. 公開API（ABI）

### 関数

* **JS/Astro**：`render(source, options?) → Promise<RenderResult>`
* **wasm**：`render(source, options) → RenderResult`（同期）
* **core**：`render(src, &Options) → RenderResult`

### 型（概念定義）

* **RenderResult**：`html`（文字列）, `headings`（`Heading[]`）
* **Heading**：`depth`（1..6）, `text`（見出しのプレーンテキスト）, `slug`（id）
* **Options**：`gfmTables`, `gfmTasklists`, `footnotes`, `smartPunct`（既定すべて有効）

> 注：JS のフロントマター（gray-matter）は rsmd の責務外。rsmd は本文のみ受け取る。

---

## 4. スラグ（id）仕様

### 方針

* **Unicode 保持**：ラテン以外（日本語など）も基本は残す。
* **空白 → ハイフン**、句読点などの区切り文字はハイフン化または削除。
* **連続ハイフンは 1 個に圧縮**、先頭末尾のハイフンは除去。
* **重複回避**：同一スラグ出現ごとに `-1`, `-2`, ... を付与。
* **空スラグ対策**：全削除後に空になった場合は `section` を用い、同様に `section-1` ...。

### 例

* `# Hello, World!` → `hello-world`
* `# こんにちは 世界` → `こんにちは-世界`
* `# A  B   C` → `a-b-c`
* `# 100%` → `100`（`%` は削除）/ 空なら `section`

> 目的：Astro の TOC/アンカーと整合、CJK を含む見出しでも安定した id。

---

## 5. 見出し収集ルール

* 見出しの**開始～終了**を一時バッファし、**中身のプレーンテキスト**を抽出して `text` に格納。
* `text` にはインライン装飾（em/strong/code 等）のマークアップは**含めない**。
* カスタム id 記法（例：`{#id}`）は**当面未対応**。将来の拡張点として予約。
* ネストや不正構造（見出しの中に見出し）には**堅牢に**：カウンタで対応し、最初の開始に対応する終了で閉じる。

---

## 6. GFM と各種オプション

* 既定で **有効**：

   * `gfmTables`（表）
   * `gfmTasklists`（タスクリスト）
   * `footnotes`（脚注）
   * `smartPunct`（スマート句読点）
* すべて **Options** で明示的に ON/OFF 可能。

> 既定 ON は「Astro でよく期待される挙動」を優先するため。

---

## 7. セキュリティ方針（サニタイズ）

* 既定は**非サニタイズ**（速度優先）。
* もし不特定ユーザー入力を扱うなら、

   1. JS 側で HTML サニタイズ、または
   2. rsmd を **二重パス**（一度 HTML 出力後にサニタイズ）で実行。
* 二重パスはオプション化（既定 OFF）。導入時はパフォーマンス影響を明記。

---

## 8. エラーハンドリング

* **core**：エラーは分類（無効な文字列/内部エラー/メモリ不足など）。
* **wasm**：Rust のエラーを JS の例外へ変換（メッセージに分類名を含める）。
* **JS**：Promise の reject として表面化。利用側で try/catch 可能。

> 初期化失敗（wasm 読み込み不可等）は明確なメッセージを返す。

---

## 9. パフォーマンス戦略 / 計測方法

### 目標（暫定）

* 小：~1KB 文書 → 1ms 未満
* 中：~10KB 文書 → < 5ms
* 大：~100KB 文書 → < 20ms
* wasm バンドルサイズ：**300KB 未満**（圧縮前）を目安

### 測定設計

* 計測値：p50/p95 レイテンシ、スループット（ops/s）、メモリピーク。
* 条件：Node 22 / Deno / ブラウザ（Chromium）で**コールド/ウォーム**を分けて採取。
* 比較：Node の remark/rehype（MDX 無効化）をベースラインに。数字は CI 上で固定入力に対し差分のみ評価。

> “10倍”はワークロード依存。**常時の保証値ではなく**、CI のリグレッション防止指標として扱う。

---

## 10. メモリ / サイズ

* wasm は**デフォルト自動拡張**（必要時）。
* 巨大文書のための**事前拡張**手順は README に記載（推奨ページ数単位）。
* サイズ監視：CI で wasm アーティファクトに**上限**（例：300KB）を設定。

---

## 11. CI / QA（最小）

* **スラグ**：CJK/記号/重複の組み合わせで期待どおりになるか。
* **見出し**：`#`～`######` の depth、インライン要素混在、空見出しの扱い。
* **GFM**：表/タスクリスト/脚注/スマート句読点の有効・無効切替。
* **再現性**：同一入力→同一出力（スナップショット差分）。
* **サイズ**：wasm のサイズ上限チェック。
* **Astro スモーク**：Content Collections 経由で `{ html, headings }` を受け取り、TOC が動くこと。

---

## 12. ディレクトリ（最小）

* **ワークスペース**：リポジトリ直下の Cargo ワークスペースに
  `packages/core` を **members** として登録する。
* **単一 crate 方針**（あなたの図のとおり）

  * `packages/core` にコア実装と **WASMバインディング（wasm.rs）** を同居させる。
  * ビルドは「ネイティブ向け」と「wasm向け」を切り替える運用にする（ターゲット分岐だけ必要）。
* **JS パッケージ**：`packages/rsmd` は Astro/JS ラッパ。

  * フロントマター分離（gray-matter）はここで行い、**本文だけ** core の `render` に渡す。
  * 返り値は常に `{ html, headings }` にそろえる。
* **命名の統一**：関数名は**全層とも `render`**、型は `Options / RenderResult / Heading`。
* **最低限のテスト**：

  * スラグの重複回避（`a-title`, `a-title-1`）
  * 見出しの depth（1..6）が揃うこと

---

## 13. Astro 連携

* 呼び出しは `render(body, options)` のみ（同期/非同期は利用環境に合わせる）。
* 戻り値 `{ html, headings }` を直接テンプレートや TOC コンポーネントに渡す。
* 既存の MDX は**拡張子で分岐**し、別経路（`@mdx-js/mdx`）で処理。スラグは wasm から `slugify` を公開し**共有**すれば整合が取れる。

---

## 14. バージョニング / 互換性

* **SemVer** 準拠。
* **破壊的変更禁止**：`RenderResult` の形（`html`, `headings[]`）は維持。追加フィールドは増やしてよいが既存の意味は変えない。
* オプションの既定値を変える場合はメジャーアップデートで明示。

---

## 15. 拡張ロードマップ

* **短期**：

   * wasm から `slugify` を**単機能公開**（MDX 経路で共有）。
   * 二重パス・サニタイズのオプション化とベンチ比較。
* **中期**：

   * ストリーミング変換の差し込み点（将来 `lol_html` 等）を ABI 外部で定義。
   * 増分レンダリング（差分構築）検討。
* **長期**：

   * 限定的プラグインブリッジ（AST 不要の軽量フィルタに限定）。
   * Rust 側でのフロントマター解析（任意、JS との二重管理を避ける場合）。

---

## 16. リスクと対応

* **CJK 見出しが空スラグになる**：Unicode 保持 + 空時 `section` フォールバックで回避。
* **HTML インジェクション懸念**：既定は信頼済み入力の前提。必要なら JS 側でサニタイズ、または二重パス。
* **wasm サイズ肥大**：CI サイズ上限で検知、機能追加時は明示的に上限を更新。
* **MDX とのズレ**：slugify を共有、見出しテキスト抽出規約（プレーンテキストのみ）を文書化。

---

## 17. 具体ユースケース（最小）

1. `.md` を読み込む → gray-matter で `frontmatter` と `body` を分離。
2. `render(body)` を呼ぶ → `{ html, headings }` を得る。
3. テンプレートに `html` を流し込み、`headings` で TOC/アンカーを生成。

---

## 18. FAQ（抜粋）

* **Q. なぜ AST を返さない？**
  **A.** パフォーマンスと ABI 安定のため。必要なら JS 側で別途 AST を生成する設計を推奨。

* **Q. サニタイズは？**
  **A.** 既定はしない。必要時のみ二重パスで。速度と安全性のトレードオフを明記。

* **Q. MDX は？**
  **A.** 当面は別経路（JS）。slugify を共有すれば TOC/アンカーは一致する。

---

## 19. 次アクション（実装順）

1. `core` の単一パス実装と、Unicode 保持スラグの確定。
2. `wasm` の `render` を公開し、最小のスモーク確認。
3. Astro から呼ぶ最小ラッパで `.md` 1 ファイルの通し確認。
4. CI：スラグ・見出し・サイズ上限の 3 点だけ先行投入。
